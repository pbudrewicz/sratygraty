#!/bin/bash

### author: p.budrewicz

. $( dirname $0 )/user.key 
VERBOSE=0
SHOW_RESPONSES=0 # show curl responses
DRY=0 # do not run curl
DRY_SCHEMA="xy" # default schema when faking bridge interactions
LIGHTS="" # light list 
SLEEP=0.7 # sleeping time for blinking etc.
STEPS="10" # number of steps in transitions
EXP="0" # linear (not exponential) brightness
PERSIST=0 # shall we continue even if lights were turned off

CRAWL=0.05
CRAWLB=10

# bulb gamut parameters
RED_CORNER="0.6915 0.3083"
GREEN_CORNER="0.17 0.7"
BLUE_CORNER="0.1532 0.0475"

# sunrise color arch and brightnes sequence
SUNRISE="0.68 0.3 1
0.62 0.37 1
0.57 0.4  3
0.52 0.41 5
0.5 0.41  9
0.48 0.41 15
0.43 0.40 27
0.4 0.38  48
0.37 0.35 83 
0.32 0.33 145
0.31 0.32 254"

LINEAR_SUNRISE="0.68 0.3 1
0.62 0.37 26
0.57 0.4  51
0.52 0.41 76
0.5 0.41  102
0.48 0.41 127
0.43 0.40 152
0.4 0.38  178
0.37 0.35 203
0.32 0.33 228
0.31 0.32 254"


TEMP=$( getopt -o b:d::ehk:l:p:Prs:v:: --long bridge:,dry::,exp,help,key:,light:,period:,persist,responses,steps:,verbose:: -n $0 -- "$@" )

if [ $? != 0 ] ; then echo "Cannot parse options. Terminating..." >&2 ; exit 1 ; fi

eval set -- "$TEMP"

dump_data () {
    echo VERBOSE=$VERBOSE
    echo SHOW_RESPONSES=$SHOW_RESPONSES
    echo DRY=$DRY
    echo LIGHTS=$LIGHTS
    echo SLEEP=$SLEEP
    echo STEPS=$STEPS
    echo EXP=$EXP
    echo PERSIST=$PERSIST
}

scan_net () {
    #     feedback -n .
    gssdp-discover -n 5 | grep Location: | while  read loc url ; do
	if curl -s $url | grep -qi "Philips hue bridge" ; then
	    echo $url |sed s/description.xml//
	    return 0;
	fi 
    done
    return 1
}

discover_bridge () {
    bridge_url=$(scan_net)
    echo bridge_url=$bridge_url
}

unjson () {
    perl -MJSON -e '$s = decode_json(<STDIN>); eval "print \$s->'$1'";'
}

feedback () {
    if [ "$VERBOSE" -gt "0" ] ; then
        echo "$@" 1>&2
    fi
}

polite_curl () {
    if  [ "$VERBOSE" -gt "1" ] || [ "$SHOW_RESPONSES" = "1" ]; then
        feedback "running curl $@"
    fi
    if [ "$DRY" = "1" ] ; then
        return
    fi
    if [ "$SHOW_RESPONSES" = "1" ]; then
        curl "$@"
    else
        curl "$@" >/dev/null 2>/dev/null
    fi
}

### some fun math...

interpolate () {

    #  feedback interpolating $@

  deb "$@"
  STEPS=$1
  SCHEMA=$2
  
  case $SCHEMA in 
      xy|hue)
          FROM1=$3
          FROM2=$4
          FROMB=$5
          TO1=$6
          TO2=$7
          TOB=$8
	  STEP=$9
          ;;
      ct)
          FROM1=$3
          FROMB=$4
          TO1=$5
          TOB=$6
	  STEP=$7
          ;;
  esac
  deb F1:$FROM1 T1:$TO1 STEPS:$STEPS STEP:$STEP
  if [ "$EXP" = "1" ] ; then
      BRI=$( calc %d "((($TOB / $FROMB) ** (1.0/$STEPS)) ** $STEP ) * $FROMB" )
  else
      BRI=$( calc %d "($TOB - $FROMB)/$STEPS * $STEP + $FROMB" ) 
  fi
  deb b:$BRI
  case $SCHEMA in 
      xy)
	  VAL1=$( calc "($TO1 - $FROM1)/$STEPS * $STEP + $FROM1" )
	  VAL2=$( calc "($TO2 - $FROM2)/$STEPS * $STEP + $FROM2" )
          deb x:$VAL1 y:$VAL2
          echo $SCHEMA $VAL1 $VAL2 $BRI
          ;;
      hue)
	  VAL1=$( calc %d "($TO1 - $FROM1)/$STEPS * $STEP + $FROM1" )
	  VAL2=$( calc %d "($TO2 - $FROM2)/$STEPS * $STEP + $FROM2" ) 
          deb hue:$VAL sat:$VAL2
          echo $SCHEMA $VAL1 $VAL2 $BRI
          ;;
      ct)
	  VAL1=$( calc %d "($TO1 - $FROM1)/$STEPS * $STEP + $FROM1" )
	  deb mirek:$VAL1
          echo $SCHEMA $VAL1 $BRI
          ;;
  esac
}

deb () {
 :  echo "$@" >&2
}

calc () {
    case $1 in
	%f|%d)
	    fmt=$1
	    shift
	    ;;
	*)
	    fmt="%f"
	    ;;
    esac
    echo -n $( echo "printf (\"$fmt\", $@)" | perl )
}

### end math
do_we_give_up () {
    if [ "$PERSIST" = "1" ] ; then return 0 ; fi
    light=$1
    if ! is_light_on $light ; then
        feedback User turned the light off - giving up
        set_color hue 45000 200 254
        set_light off         
        exit 0
    fi
}
    
for_lights () {
    mandatory_lights
    for light in $LIGHTS ; do
        $* &
    done
    wait
}

alert () { # TODO: just one light! check with other (e.g. blink)
    
    mandatory_lights
    set_light on 
    feedback alert on light $light
    polite_curl -s -X PUT -d '{"alert":"select"}' http://$bridge_ip/api/$user_key/lights/$light/state 
}

time_2_sec () {
    # calculate how many seconds is in 3:00m
    :    
}

first ()
{
    echo $1
}

transit_to_color () {
    # gently change current color into new one

HELPTEXT="
hue transit {color} {brightness} - must be in currently used schema
"
    schema=$1
    if [ "$schema" = "" ] ; then
	show_help 1
    fi
    SAVED_COLOR=$( get_color $light )
    SAVED_SCHEMA=$( first $SAVED_COLOR )
    if [ "$schema" != "$SAVED_SCHEMA" ] ; then
        echo "Cannot transit from $SAVED_SCHEMA to $schema"
        exit 1
    fi
    feedback transit from $SAVED_COLOR to $* in $STEPS steps
    for i in $( seq 1 $STEPS ) ; do
        case $schema in
            xy|hue)                                
                if [ "$4" = "" ] ; then
                    show_help 1
                fi
                NEW_COLOR=$( interpolate $STEPS $SAVED_COLOR $2 $3 $4 $i) ;;            
            ct)
                if [ "$3" = "" ] ; then
                    show_help 1
                fi
                NEW_COLOR=$( interpolate $STEPS $SAVED_COLOR $2 $3  $i) ;;
            *)
                show_help 1 ;;
        esac
        set_bulb_color $light $NEW_COLOR 
        sleep $SLEEP
        do_we_give_up $light
    done    
}

hue_pulse () {
    SAVED_COLOR=$( get_color $light )
    set_bulb_color $*
    sleep $SLEEP;
    set_bulb_color $light $SAVED_COLOR
}

clone_light () {
HELPTEXT="
hue clone LIGHT - set light as current LIGHT
"
    if [ "$1" = "" ] ; then
        show_help 1
    fi
    set_color $(get_color $1)
}

blink () { # TODO: every procedure should use one light! 
    #uses $LIGHTS and $light
    HELPTEXT="
hue blink 
       until time
       for period
       once
       times number
    differrent time formats accepted
"
    cmd=$1
    shift
    # $light set outside
    case $cmd in
	[u]ntil) # until is a keyword and breaks emacs's and vim's formatting. LOL
	    if [ "$1" = "" ] ; then
		show_help 1
	    fi
	    feedback blinking until $1
	    UNTIL=$( date --date "$TIME" +%s)
	    ;;
	[f]or) # for is a keyword and breaks emacs's and vim's formatting. LOL
	    if [ "$1" = "" ] ; then
		show_help 1
	    fi
	    feedback blinking for $1 seconds
	    UNTIL=$(( $( date +%s ) + $1))
	    ;;
	once)
	    feedback blinking once
	    alert $light
	    exit 0
	    ;;
	times)
	    if [ "$1" = "" ] ; then
		show_help 1
	    fi
	    feedback blinking $1 times
	    for i in $(seq 1 $1) ; do
		alert ; sleep $SLEEP
                do_we_give_up $light
	    done
	    exit 0
	    ;;
	*)
	    show_help 1
	    ;;
    esac
		
    mandatory_lights
    set_light on
    sleep 1 # wait 4 reaction

    while [ $( date +%s )  -lt $UNTIL ] ; do        
        alert $light
        sleep $SLEEP
        do_we_give_up $light 
    done

}


color_loop () { 

    effect=colorloop
    if [ "$1" = "off" ] ; then
        effect=none
        shift
    fi

    if [ "$1" = "" ] ; then
        echo "$0 [off] light_list"
        exit 0
    fi

    for light; do
        polite_curl -s -X PUT -d '{"effect":"'$effect'"}' http://$bridge_ip/api/$user_key/lights/$light/state 
    done
}

random () {
    if [ "$1" = "" ] ; then
	RANGE=1
    else
	RANGE=$1
    fi
    calc "$RANDOM / 32767 * $RANGE"
}

adjust_color () {

    SCHEMA=$1
    BX=$2; BY=$3; BB=$4
    DX=$5; DY=$6; DB=$7
    
    echo $SCHEMA $( calc $BX + $DX ) $( calc $BY + $DY ) $( calc %d $BB + $DB )
}

chase () {

  light=$1 
  shift
  while [ "$1" != "$light" ] ; do 
    shift
  done
  target=$2  

  crawl $light $target  

}

crawl () {

#TODO: Implement crawiling for other schemas
    HELPTEXT="
hue crawl [x [y [b]] ] -- crawl color in CIE space in x and y range 
                     default y = x; x = 0.05; b=10
"

    BASE_COLOR=$( get_color $2 )
    for i in $(seq 1 10 ) ; do
        R=$( random 6.283 )
	# DX=$( calc $( random $CRAWL ) - $CRAWL / 2 ) # uniform on |x,y| disc
	# DY=$( calc $( random $CRAWL ) - $CRAWL / 2 ) #
        DX=$( calc "$CRAWL * sin( $R ) " )           # uniform on a circle 
        DY=$( calc "$CRAWL * cos( $R ) " )           #
	DB=$( calc $( random $CRAWLB ) - $CRAWLB / 2 )
	transit_to_color $1 $( adjust_color $BASE_COLOR $DX $DY $DB ) 
	sleep $SLEEP
    done
    transit_to_color $1 $BASE_COLOR
    
}

fade () { 

HELPTEXT="
hue fade 
     until time
     for   period
"
    
    time_parameter=$1
    shift

    sleep=$time_parameter
    
    for light  in $LIGHTS ; do
	{
	    b=$(  get_brightness $light)
	    sleep=1 # TODO: it will be calculated depending on time_parameter  AND something 
	    while [ $b -gt 0 ] ; do
		set_brightness $b $light
		sleep $SLEEP
	        b=$(( $(  get_brightness $light) - 1 )) # we accept external changes...
	    done 
	    set_light off $light
	} &
    done
    wait

}

get_color () { # one light only

    if [ "$1" = "" ] ; then
        show_help 1
    fi

    if [ "$DRY" = "1" ] ; then
        case $DRY_SCHEMA in 
            xy)
                feedback Faking light $1 is $RED_CORNER 111.
                echo xy $RED_CORNER 111
                ;;
            ct)
                feedback Faking light $1 is ct 200 111.
                echo ct 200 111
                ;;
            hue)
                feedback Faking light $1 is hue 45000 150 111.
                echo hue 45000 150 111
                ;;
            *)
                show_help 1
                ;;
        esac
        return 
    fi
    L=$( get_lights_json $1 )
    color_type=$( echo "$L" | unjson '{state}{colormode}' )
    on=$( echo "$L" | unjson '{state}{on}' )
    case $color_type in
	xy)
	    x=$( echo $L | unjson '{state}{xy}[0]' )
	    y=$( echo $L | unjson '{state}{xy}[1]' )
	    bri=$( echo $L | unjson '{state}{bri}' )
	    echo xy $x $y $bri  $( if ! is_light_on $1; then echo "# off" ; fi )
	    ;;
	hs)
	    hue=$( echo $L | unjson '{state}{hue}' )
	    sat=$( echo $L | unjson '{state}{sat}' )
	    bri=$( echo $L | unjson '{state}{bri}' )
	    echo hue $hue $bri $sat 
	    ;;
	ct)
	    ct=$( echo $L | unjson '{state}{ct}' )
	    bri=$( echo $L | unjson '{state}{bri}' )
	    echo ct $ct $bri
            ;;
        *)
            show_help 1
            ;;
    esac
}

get_brightness () { 
    if [ "$DRY" = "1" ] ; then
        echo 111
        return
    fi
    echo $(get_lights_json $1 | unjson '{state}{bri}' )
}


get_config_json () { 
    curl -s -X GET  http://$bridge_ip/api/$user_key/config
}


get_lights_json () { 

    if [ "$1" != "" ] ; then
        curl -s -X GET  http://$bridge_ip/api/$user_key/lights/$1
    else
        curl -s -X GET  http://$bridge_ip/api/$user_key/lights
    fi
    
}


get_on_off () { 
    get_lights_json $1 |unjson '{state}{on}'
}


is_light_on () {

    if [ "$DRY" = "1" ] ; then
        feedback Fake light $1 is on
        return 0
    fi

    if [ "$(get_on_off $1)" = "1" ] ; then
        return 0
    else
        return 1
    fi
}


set_light () { 

    HELPTEXT="
hue light on|off
"

    if [ "$1" = "" ] ; then
        show_help 1
    fi

    ONOFF=$1
    case  $ONOFF in
        on)
            mandatory_lights
            feedback setting light $light on
            polite_curl -s -X PUT -d '{"on":true}' http://$bridge_ip/api/$user_key/lights/$light/state 
            ;;
        off)
            mandatory_lights
            feedback setting light $light off
            polite_curl -s -X PUT -d '{"on":false}' http://$bridge_ip/api/$user_key/lights/$light/state 
            ;;
        *)
            show_help 1
    esac
    
}

my_loop () { 
    hue=0

    while true ; do
        ./set_color.sh $1 hue $hue 200 100
        hue=$(( ( $hue + 10000 ) % 65535 ))
        sleep $SLEEP
    done
}


set_brightness () { 

    HELPTEXT="
hue set brightness {brightness:1-254} - setting brightnes
"
    
    if [ "$1" = "" ] ; then
        show_help 1
    fi    
    BRIGHTNESS=$1
    mandatory_lights
    feedback setting brightness to $BRIGHTNESS    
    for light in $LIGHTS ; do
        polite_curl -s -X PUT -d '{"bri":'$BRIGHTNESS'}' http://$bridge_ip/api/$user_key/lights/$light/state 
    done
}

set_hue () {
    HELPTEXT="
hue set color hue {hue:0-65535} {saturation:1-200} {brightness:1-254}
   
"
    if [ "$3" = "" ] ; then
        show_help 1
    fi    
    mandatory_lights
    feedback setting hue to $*
    polite_curl -s -X PUT -d '{"on":true, "hue":'$1', "sat":'$2',"bri":'$3'}' http://$bridge_ip/api/$user_key/lights/$light/state     
}

set_xy () {
    HELPTEXT="
hue set color xy {x} {y} {brightness:1-254}

"
    if [ "$3" = "" ] ; then
        show_help 1
    fi    
    mandatory_lights
    feedback setting CIE color of light $light to $*
    polite_curl -s -X PUT -d '{"on":true, "xy":['$1', '$2'], "bri":'$3'}' http://$bridge_ip/api/$user_key/lights/$light/state 
}

set_ct () {
    HELPTEXT="
hue set color ct  {mirek:153-500} {brightness:1-254}
            153 - cold -- 500 - warm
"
    if [ "$2" = "" ] ; then
        show_help 1
    fi    
    mandatory_lights
    feedback setting light $light to  mirek $*
    polite_curl -s -X PUT -d '{"on":true, "ct":'$1', "bri":'$2'}' http://$bridge_ip/api/$user_key/lights/$light/state 
}
    
set_color () { 
    HELPTEXT="
hue set color 
          hue {hue:0-65000} {saturation:1-200} {brightness:1-254}
          xy  {x} {y} {brightness:1-254}
          ct  {mirek:153-500} {brightness:1-254}
"
    case $1 in 
        xy|ct|hue)            
            mandatory_lights
            for light in $LIGHTS ; do 
                set_bulb_color $light $*
            done
            ;;
        *)
            show_help 1
            ;;
    esac
}

set_bulb_color () {
    light=$1
    shift
    schema=$1
    shift
    case $schema in
	xy)	
            set_xy $*
            ;;
        ct)
            set_ct $*
            ;;
        hue)
            set_hue $*
            ;;
        *)
            show_help 1 
            ;;            
    esac
    
}


set_saturation () { 
    HELPTEXT="
hue set saturation {saturation:1-200} - setting saturation
"
    
    if [ "$1" = "" ] ; then
        show_help 1
    fi    
    mandatory_lights
    feedback setting saturation to $* 
    for light ; do
        polite_curl -s -X PUT -d '{"sat":'$v'}' http://$bridge_ip/api/$user_key/lights/$light/state 
    done
}


show_sequence () { 
    #TODO: help
HELPTEXT="
feed STDIN
"

    while read one two three four ; do 
        case one in
            xy) 
                feedback setting xy $two $three $four
                set_color xy $two $three $four
                ;;
            hue)
                feedback setting hue $two $three $four
                set_color hue $two $three $four
                ;;
            ct) 
                feedback setting ct $two $three
                set_color ct $two $three
                ;;
            *) 
                feedback setting xy $one $two $three
                set_color xy $one $two $three
                ;;
        esac           
        sleep $SLEEP
        do_we_give_up $light
    done 
}


sunrise () { 
    #TODO: help, internal interpolation
    if [ "$EXP" = "1" ] ; then
	echo -e "$SUNRISE" |$(dirname $0)/../scripts/interpolate.pl $STEPS %f %f *%d  | show_sequence
    else
	echo -e "$LINEAR_SUNRISE" |$(dirname $0)/../scripts/interpolate.pl $STEPS %f %f %d  | show_sequence
    fi
}


sunset () { 
    #TODO: help, internal interpolation
    if [ "$EXP" = "1" ] ; then
	echo -e "$SUNRISE" |tac|$(dirname $0)/../scripts/interpolate.pl $STEPS %f %f *%d  | show_sequence
    else
	echo -e "$LINEAR_SUNRISE" |tac|$(dirname $0)/../scripts/interpolate.pl $STEPS %f %f %d  | show_sequence
    fi
    set_light off 
}

set_value() {
    HELPTEXT="
hue set 
       brightness value - set brightness (1-254)
       saturation value - set saturation (1-200)
       color 
         hue {hue} {saturation} {brightness}
         xy  {x} {y} {brightness}
         ct  {mirek} {brightness}
      light
         on
         off
"
    cmd=$1
    shift
    case $cmd in
        brightness)
            set_brightness $*
            ;;
        saturation)
            set_saturation $*
            ;;
        color)            
            set_color $*
            ;;
        light)
            set_light $*
            ;;
        *)
            show_help 1
            ;;
    esac
}

get_value() {
    HELPTEXT="
hue get
        brightness - brightness of light
        onoff  - on/off status of light
        config - full bridge config JSON
        color  - get color description 
        lights - lights data in JSON format
        mode   - current color mode (hue/xy/ct)
"
    cmd=$1
    shift
    case $cmd in
        brightness)
	    get_brightness $*
            ;;
        onoff)
            get_on_off $*
	    ;;
        config)
            feedback getting config
	    get_config_json $*
            ;;
        lights)
	    get_lights_json $*
	    ;;
        color)
	    get_color $1
            ;;
        mode)
            ;;
        *)
            show_help 1
            ;;
    esac
}


HELPTEXT="
Usage: 
  hue [-b bridge_ip][-d][-e][-h][-k user_key][[-l number] ... ][-p period][-r][-s steps][[-v[level]] ... ] command
    Options are:
      -b|--bridge_ip -- IP address of the hue bridge device
      -d|--dry       -- dry run, do not bother the bridge
      -e|--exp       -- exponential brightness changes in sequencess or transitions
      -h|--help      -- this help
      -k|--key       -- user key for the bridge
      -l|--light     -- light to change (add -l for every light or list in quoted string)
                        --light is MANDATORY for some commands
      -p|--period    -- period for blinks in seconds (default ${SLEEP}s)
      -P|--persist   -- keep changing lights even when they were turned off
      -r|--responses -- show http responses from the bridge
      -s|--steps     -- number of steps in transitions
      -v|--verbose   -- give feedback on taken actions (more -v increases level)
    Commands are:
      alert - one blink please
      blink 
        until - start blinking until date/time
        for   - start blinking for some time
        once  - just blink once
        times - blink number of times
      chase   - make lights chase each other colors #TODO
      clone LIGHT - set light as another light 
      crawl   - make random changes in colors #TODO
      fade 
        until - fade away until date/time #TODO
        for   - fade away for some time #TODO
      get 
        config - fetch config from bridge in JSON
        lights - get lights status in JSON
        brightness LIGHT - get light brightness value for LIGHT
        onoff LIGHT - get on/of status of the light LIGHT
        color LIGHT - get color description of the light LIGHT
      is
        on - return \"light is on\" status (0/1 - true/false) 
      loop #TODO
        mode  - start color loop mode #TODO
        custom  - start custom color loop #TODO
      on           - turn on the light
      off          - turn off the light
      pulse COLOR  - set COLOR for a period and go back
      scan         - scan network for a bridge
      set 
        color COLOR - set all color parameters
        brightness  - set brightness 
        saturation  - set saturation
        light 
          on       - turn on the light
          off      - turn off the light
      show    - show sequence 
      sunset  - show sunset sequence 
      sunrise - show sunrise sequence 
      transit - gently transit to new color 

LIGHT - number of light source
COLOR - color description: run 
  $(basename $0) set color 
for help on describing color
"

mandatory_lights () {
    if [ "$LIGHTS" = "" ] ; then
        echo "Unknown command or mandatory lights not specified. Try $0 -h"
        exit 1
    fi
}

show_help () {
    if [ "$1" = "0" ] ; then
        echo "$HELPTEXT" 
    else
        echo "$HELPTEXT" >&2 
    fi
    exit $1
}

while true ; do
    case "$1" in
        -b|--bridge)
            bridge_ip="$2"; shift 2;;
        -d|--dry)
            DRY=1; 
            if [ "$2" != "" ] ; then
                DRY_SCHEMA=$2
            fi
            shift 2;
            ;;
	-e|--exp)
	    EXP="1"; shift ;;
        -h|--help)
            show_help 0 ;;
        -k|--key)
            user_key="$2"; shift 2;;
        -l|--light)
            LIGHTS="$LIGHTS $2"; shift 2;;
	-p|--period)
	    SLEEP="$2"; shift 2;;
        -P|--persist)
            PERSIST=1 ; shift ;;
        -r|--responses)
            SHOW_RESPONSES=1;  shift ;;
        -s|--steps)
            STEPS="$2"; shift 2 ;;
        -v|--verbose)
            case "$2" in
                "")
                    VERBOSE=$(( $VERBOSE + 1 ));;
                [0-9])
                    VERBOSE="$2" ;;
            esac
            shift 2;;
        --) 
            shift ; break ;;
        *) echo "Internal error!" ; exit 1 ;;
    esac
done

cmd=$1
shift
if [ "$cmd" = "" ] ; then
    echo "No command specified. Try $0 -h "
    exit 1
fi
case $cmd in
    alert)
        for_lights alert 
	;;
    blink)
        for_lights blink $* 
	;;
    color)
        for_lights set_color $* 
	;;
    chase)
	mandatory_lights
        for light in $LIGHTS ; do
          chase $light $LIGHTS $LIGHTS &
        done
        wait
        ;;
    crawl)
	mandatory_lights
	for light in $LIGHTS ; do
	    crawl $light $light &
	done
	wait
	;;
    scan)
	discover_bridge
	exit 0
	;;
    get)
	get_value $*
	;;
    is)
	is_light_on $*
	;;
    dump)
	dump_data
	exit 0
	;;
    set)	
	set_value $*
	;;
    *)
	mandatory_lights
	case $cmd in
	    clone)                
                clone_light $1
		;;
	    fade)
                for_lights fade $* 
		;;
	    loop)
		;;
	    my_loop)
		;;
	    off)
                for_lights set_light off $* 
		;;
	    on)
		for_lights set_light on $* 
		;;
	    pulse)
                for_lights hue_pulse $* 
		;;
	    show)
                for_lights $cmd $* 
		;;
	    sunrise)
                for_lights $cmd $*
		;;
	    sunset)
                for_lights $cmd $*
		;;
            transit)
                for_lights transit_to_color $* 
                ;;
	    *)
		show_help 1
		;;
	esac
	
esac
