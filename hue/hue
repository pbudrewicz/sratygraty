#!/bin/bash

### author: p.budrewicz

. $( dirname $0 )/user.key 
VERBOSE=0
SHOW_RESPONSES=0
DRY=0
LIGHTS=""
SLEEP=0.7

RED_CORNER="0.6915 0.3083"
GREEN_CORNER="0.17 0.7"
BLUE_CORNER="0.1532 0.0475"

SUNRISE="0.68 0.3 1
0.62 0.37 1
0.57 0.4  3
0.52 0.41 5
0.5 0.41  9
0.48 0.41 15
0.43 0.40 27
0.4 0.38  48
0.37 0.35 83 
0.32 0.33 145
0.31 0.32 254"

TEMP=$( getopt -o b:dhk:l:p:rv:: --long bridge:,dry,help,key:,light:,period:,responses,verbose:: -n $0 -- "$@" )

if [ $? != 0 ] ; then echo "Cannot parse options. Terminating..." >&2 ; exit 1 ; fi

eval set -- "$TEMP"

dump_data () {
    echo VERBOSE=$VERBOSE
    echo SHOW_RESPONSES=$SHOW_RESPONSES
    echo DRY=$DRY
    echo LIGHTS=$LIGHTS
    echo SLEEP=$SLEEP
}

scan_net () {
    #     feedback -n .
    gssdp-discover -n 5 | grep Location: | while  read loc url ; do
	if curl -s $url | grep -qi "Philips hue bridge" ; then
	    echo $url |sed s/description.xml//
	    return 0;
	fi 
    done
    return 1
}

discover_bridge () {
    bridge_url=$(scan_net)
    echo bridge_url=$bridge_url
}

unjson () {
    perl -MJSON -e '$s = decode_json(<STDIN>); eval "print \$s->'$1'";'
}

feedback () {
    if [ "$VERBOSE" -gt "0" ] ; then
        echo "$@"
    fi
}

polite_curl () {
    if  [ "$VERBOSE" -gt "1" ] || [ "$DRY" = "1" ] || [ "$SHOW_RESPONSES" = "1" ]; then
        echo "running curl $@"
    fi
    if [ "$DRY" = "1" ] ; then
        return
    fi
    if [ "$SHOW_RESPONSES" = "1" ]; then
        curl "$@"
    else
        curl "$@" >/dev/null 2>/dev/null
    fi
}

### some fun math...

interpolate () {

  deb "$@"
  LEFT=$1
  RIGHT=$2
  LCOLORX=$3
  LCOLORY=$4
  RCOLORX=$5
  RCOLORY=$6
  VALUE=$7
  FRAC=$( calc "( $VALUE  - $LEFT ) / ( $RIGHT - $LEFT )" )
  deb frac:$FRAC
  COLX=$( calc "$LCOLORX + $FRAC * ($RCOLORX - $LCOLORX)")
  deb x:$COLX
  COLY=$( calc "$LCOLORY + $FRAC * ($RCOLORY - $LCOLORY)" )
  deb x:$COLY
  echo $COLX $COLY
}

deb () {
  : echo "$@" >&2
}

calc () {
    RES="$( echo "$@" | bc -l )"
    printf "%f" $RES
}

### end math

alert () { # uses $LIGHTS 
    
    for light in $LIGHTS; do
        set_light on 
        feedback alert 
        polite_curl -s -X PUT -d '{"alert":"select"}' http://$bridge_ip/api/$user_key/lights/$light/state 
    done
}

time_2_sec () {
    # calculate how many seconds is in 3:00m
    :    
}

transit_to_color () {
    # gently change current color into new one
    
    :
}

hue_pulse () {
    for light in $LIGHTS ; do
	SAVED_COLOR=$( get_color $light )
	set_color $*
    done
    sleep $SLEEP;
    for light in $LIGHTS ; do 
	set_color $SAVED_COLOR
    done
}

blink () { # uses $LIGHTS and $light
    HELPTEXT="
hue blink 
       until time
       for period
       once
       times number
    differrent time formats accepted
"
    cmd=$1
    shift
    case $cmd in
	[u]ntil) # until is a keyword and breaks emacs's and vim's formatting. LOL
	    if [ "$1" = "" ] ; then
		show_help 1
	    fi
	    feedback blinking until $1
	    UNTIL=$( date --date "$TIME" +%s)
	    ;;
	[f]or) # for is a keyword and breaks emacs's and vim's formatting. LOL
	    if [ "$1" = "" ] ; then
		show_help 1
	    fi
	    feedback blinking for $1 seconds
	    UNTIL=$(( $( date +%s ) + $1))
	    ;;
	once)
	    feedback blinking once
	    alert
	    exit 0
	    ;;
	times)
	    if [ "$1" = "" ] ; then
		show_help 1
	    fi
	    feedback blinking $1 times
	    for i in $(seq 1 $1) ; do
		alert ; sleep $SLEEP
	    done
	    exit 0
	    ;;
	*)
	    show_help 1
	    ;;
    esac
		

    for light in $LIGHTS ; do 	
      set_light on
    done
    sleep 1 # wait 4 reaction

    while [ $( date +%s )  -lt $UNTIL ] ; do        
        for light in $LIGHTS; do            
            if  is_light_on $light ; then 
                alert $light
            else
                exit 0
            fi            
        done
        sleep $SLEEP
    done

}


color_loop () { 

    effect=colorloop
    if [ "$1" = "off" ] ; then
        effect=none
        shift
    fi

    if [ "$1" = "" ] ; then
        echo "$0 [off] light_list"
        exit 0
    fi


    . $( dirname $0 )/user.key 


    for light; do
        polite_curl -s -X PUT -d '{"effect":"'$effect'"}' http://$bridge_ip/api/$user_key/lights/$light/state 
    done
}


fade () { 

HELPTEXT="
hue fade 
     until time
     for   period
"
    
    time_parameter=$1
    shift

    sleep=$time_parameter
    
    for light  in $LIGHTS ; do
	{
	    b=$(  get_brightness $light)
	    sleep=1 # TODO: it will be calculated depending on time_parameter  AND something 
	    while [ $b -gt 0 ] ; do
		set_brightness $b $light
		sleep $SLEEP
		b=$(( $b - 1 ))
	    done 
	    set_light off $light
	} &
    done
    wait

}

get_color () { # one light only

    L=$( get_lights_json $1 )
    color_type=$( echo "$L" | unjson '{state}{colormode}' )
    on=$( echo "$L" | unjson '{state}{on}' )
    case $color_type in
	xy)
	    x=$( echo $L | unjson '{state}{xy}[0]' )
	    y=$( echo $L | unjson '{state}{xy}[1]' )
	    bri=$( echo $L | unjson '{state}{bri}' )
	    echo xy $x $y $bri  $( if ! is_light_on $1; then echo "# off" ; fi )
	    ;;
	hs)
	    hue=$( echo $L | unjson '{state}{hue}' )
	    sat=$( echo $L | unjson '{state}{sat}' )
	    bri=$( echo $L | unjson '{state}{bri}' )
	    echo hue $hue $bri $sat 
	    ;;
	ct)
	    ct=$( echo $L | unjson '{state}{ct}' )
	    bri=$( echo $L | unjson '{state}{bri}' )
	    echo ct $ct $bri
    esac
}

get_brightness () { 
    echo $(get_lights_json $1 | unjson '{state}{bri}' )
}


get_config_json () { 
    curl -s -X GET  http://$bridge_ip/api/$user_key/config
}


get_lights_json () { 

    if [ "$1" != "" ] ; then
        curl -s -X GET  http://$bridge_ip/api/$user_key/lights/$1
    else
        curl -s -X GET  http://$bridge_ip/api/$user_key/lights
    fi
    
}


get_on_off () { 
    get_lights_json $1 |unjson '{state}{on}'
}


is_light_on () {

    if [ "$DRY" = "1" ] ; then
        feedback Fake light $1 is on
        return 0
    fi

    if [ "$(get_on_off $1)" = "1" ] ; then
        return 0
    else
        return 1
    fi
}


set_light () { 

    HELPTEXT="
hue light on|off
"
   
    ONOFF=$1

    shift

    for light in $LIGHTS ; do

    case  $ONOFF in
        on)
            feedback setting light on
            polite_curl -s -X PUT -d '{"on":true}' http://$bridge_ip/api/$user_key/lights/$light/state ;;
        off)
            feedback setting light off
            polite_curl -s -X PUT -d '{"on":false}' http://$bridge_ip/api/$user_key/lights/$light/state ;;
        *)
            show_help 1
    esac

  done
}

my_loop () { 
    hue=0

    while true ; do
        ./set_color.sh $1 hue $hue 200 100
        hue=$(( ( $hue + 10000 ) % 65535 ))
        sleep $SLEEP
    done
}


set_brightness () { 
    BRIGHTNESS=$1
    shift
    feedback setting brightness to $BRIGHTNESS    
    for light in $LIGHTS ; do
        polite_curl -s -X PUT -d '{"bri":'$BRIGHTNESS'}' http://$bridge_ip/api/$user_key/lights/$light/state 
    done
}

set_hue () {
    HELPTEXT="
hue set color hue {hue:0-65535} {saturation:1-200} {brightness:1-254}
   
"
    if [ "$3" = "" ] ; then
        show_help 1
    fi    
    feedback setting hue to $*
    polite_curl -s -X PUT -d '{"on":true, "hue":'$1', "sat":'$2',"bri":'$3'}' http://$bridge_ip/api/$user_key/lights/$light/state     
}

set_xy () {
    HELPTEXT="
hue set color xy {x} {y} {brightness:1-254}

"
    if [ "$3" = "" ] ; then
        show_help 1
    fi    
    feedback setting CIE color to $*
    polite_curl -s -X PUT -d '{"on":true, "xy":['$1', '$2'], "bri":'$3'}' http://$bridge_ip/api/$user_key/lights/$light/state 
}

set_ct () {
    HELPTEXT="
hue set color ct  {mirek:153-500} {brightness:1-254}
            153 - cold -- 500 - warm
"
    if [ "$2" = "" ] ; then
        show_help 1
    fi    

    feedback setting mirek to $*
    polite_curl -s -X PUT -d '{"on":true, "ct":'$1', "bri":'$2'}' http://$bridge_ip/api/$user_key/lights/$light/state 
}
    
set_color () { 

    HELPTEXT="
hue set color 
          hue {hue:0-65000} {saturation:1-200} {brightness:1-254}
          xy  {x} {y} {brightness:1-254}
          ct  {mirek:153-500} {brightness:1-254}
"
    schema=$1
    shift

    for light in $LIGHTS ; do
        case $schema in
	    xy)	
                set_xy $*
                ;;
            ct)
                set_ct $*
                ;;
            hue)
                set_hue $*
                ;;
            *)
                show_help 1 
                ;;            
        esac
    done
}


set_saturation () { 

    feedback setting saturation to $* 
    for light ; do
        polite_curl -s -X PUT -d '{"sat":'$v'}' http://$bridge_ip/api/$user_key/lights/$light/state 
    done
}


show_sequence () { 

    while read one two three four ; do 
        case one in
            xy) 
                feedback setting xy $two $three $four
                set_color xy $two $three $four
                ;;
            hue)
                feedback setting hue $two $three $four
                set_color hue $two $three $four
                ;;
            ct) 
                feedback setting ct $two $three
                set_color ct $two $three
                ;;
            *) 
                feedback setting xy $one $two $three
                set_color xy $one $two $three
                ;;
        esac           
        sleep $SLEEP
        if ! is_light_on $light ; then
            set_color hue 45000 200 254
            set_light off 
            exit 0
        fi
    done 
}


sunrise () { 
    echo -e "$SUNRISE" |$(dirname $0)/../scripts/interpolate.pl 10 %f %f *%d  | show_sequence
}


sunset () { 
    echo  -e "$SUNRISE" | tac |$(dirname $0)/../scripts/interpolate.pl 10 %f %f *%d  | show_sequence
    set_light off 
}

set_value() {

    HELPTEXT="
hue set 
       brightness value - set brightness (1-254)
       saturation value - set saturation (1-200)
       color 
         hue {hue} {saturation} {brightness}
         xy  {x} {y} {brightness}
         ct  {mirek} {brightness}
      light
         on
         off
"
    cmd=$1
    shift
    case $cmd in
        brightness)
            set_brightness $*
            ;;
        saturation)
            set_saturation $*
            ;;
        color)            
            set_color $*
            ;;
        light)
            set_light $*
            ;;
        *)
            show_help 1
            ;;
    esac
}

get_value() {
    HELPTEXT="
hue get
        brightness - brightness of light
        onoff  - on/off status of light
        config - full bridge config JSON
        color  - get color description 
        lights - lights data in JSON format
        mode   - current color mode (hue/xy/ct)
"
    cmd=$1
    shift
    case $cmd in
        brightness)
	    get_brightness $*
            ;;
        onoff)
            get_on_off $*
	    ;;
        config)
            feedback getting config
	    get_config_json $*
            ;;
        lights)
	    get_lights_json $*
	    ;;
        color)
	    get_color $1
            ;;
        mode)
            ;;
        *)
            show_help 1
            ;;
    esac
}


HELPTEXT="
Usage: 
  hue [-b bridge_ip][-d][-h][-k user_key][[-l number] ... ][-p period][-r][[-v[level]] ... ] command
    Options are:
      -b|--bridge_ip -- IP address of the hue bridge device
      -d|--dry       -- dry run, do not bother the bridge
      -h|--help      -- this help
      -k|--key       -- user key for the bridge
      -l|--light     -- light to change (add -l for every light or list in quoted string)
      -p|--period    -- period for blinks in seconds (default ${SLEEP}s)
      -r|--responses -- show http responses from the bridge
      -v|--verbose   -- give feedback on taken actions (more -v increases level)
    Commands are:
      alert - one blink please
      blink 
        until - start blinking until date/time
        for   - start blinking for some time
        once  - just blink once
        times - blink number of times
      clone   - set light as another light 
      fade 
        until - fade away until date/time #TODO
        for   - fade away for some time #TODO
      get 
        config - fetch config from bridge in JSON
        lights - get lights status in JSON
        brightness LIGHT - get light brightness value for LIGHT
        onoff LIGHT - get on/of status of the light LIGHT
        color LIGHT - get color description of the light LIGHT
      is
        on - return \"light is on\" status (0/1 - true/false) # TODO
      loop #TODO
        mode  - start color loop mode #TODO
        custom  - start custom color loop #TODO
      on           - turn on the light
      off          - turn off the light
      pulse COLOR  - set COLOR for a period and go back
      scan         - scan network for a bridge
      set 
        color COLOR - set all color parameters
        brightness  - set brightness 
        saturation  - set saturation
        light 
          on       - turn on the light
          off      - turn off the light
      show    - show sequence #TODO
      sunset  - show sunset sequence #TODO
      sunrise - show sunrise sequence #TODO
      transit - gently transit to new color #TODO
"

mandatory_lights () {
    if [ "$LIGHTS" = "" ] ; then
        echo "Unknown command or mandatory lights not specified. Try $0 -h"
        exit 1
    fi
}

show_help () {
  echo "$HELPTEXT"
  exit $1
}

while true ; do
    case "$1" in
        -b|--bridge)
            bridge_ip="$2"; shift 2;;
        -d|--dry)
            DRY=1; shift ;;
        -h|--help)
            show_help 0 ;;
        -k|--key)
            user_key="$2"; shift 2;;
        -l|--light)
            LIGHTS="$LIGHTS $2"; shift 2;;
	-p|--period)
	    SLEEP="$2"; shift 2;;
        -r|--responses)
            SHOW_RESPONSES=1;  shift ;;
        -v|--verbose)
            case "$2" in
                "")
                    VERBOSE=$(( $VERBOSE + 1 ));;
                [0-9])
                    VERBOSE="$2" ;;
            esac
            shift 2;;
        --) 
            shift ; break ;;
        *) echo "Internal error!" ; exit 1 ;;
    esac
done

cmd=$1
shift
if [ "$cmd" = "" ] ; then
    echo "No command specified. Try $0 -h "
    exit 1
fi
case $cmd in
    scan)
	discover_bridge
	exit 0
	;;
    get)
	get_value $*
	;;
    is)
	is_light_on $*
	;;
    dump)
	dump_data
	exit 0
	;;
    *)
	mandatory_lights
	case $cmd in
	    alert)
		alert 
		;;
	    blink)
		blink $*
		;;
	    clone)
		set_value color $(get_color $1)
		;;
	    fade)
		fade $*
		;;
	    loop)
		;;
	    my_loop)
		;;
	    off)
		lights off $*
		;;
	    on)
		lights on $*
		;;
	    pulse)
		hue_pulse $*
		;;
	    set)
		set_value $*
		;;
	    show)
		show_sequence 
		;;
	    sunrise)
                sunrise
		;;
	    sunset)
                sunset
		;;
	    *)
		show_help 1
		;;
	esac
	
esac
